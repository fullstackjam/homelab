{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"k8s-gitops","text":"<p>This is a repository for my Kubernetes cluster. I try to adhere to metalstructure as Code (IaC) and GitOps practices using tools like Kubernetes, Argo, Renovate and GitHub Actions.</p>"},{"location":"concepts/certificate-management/","title":"Certificate management","text":"<p>Certificates are generated and managed by cert-manager with Let's Encrypt. By default certificates are valid for 90 days and will be renewed after 60 days.</p> <p>cert-manager watches <code>Ingress</code> resources across the cluster. When you create an <code>Ingress</code> with a supported annotation:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    cert-manager.io/cluster-issuer: letsencrypt-prod\n  name: foo\nspec:\n  rules:\n    - host: foo.example.com\n      # ...\n  tls:\n    - hosts:\n        - foo.example.com\n      secretName: foo-tls-certificate\n</code></pre> <pre><code>flowchart LR\n  User -- 6 --&gt; Ingress\n\n  subgraph cluster[Homelab cluster]\n    Ingress --- Secret\n    Ingress -. 1 .-&gt; Certificate\n    Certificate -. 5 .-&gt; Secret\n    Certificate -- 2 --&gt; CertificateRequest -- 3 --&gt; Order -- 4 --&gt; Challenge\n  end\n\n  Order -.- ACMEServer[ACME server]\n\n  subgraph dnsprovider[DNS provider]\n    TXT\n  end\n\n  Challenge -- 4a --&gt; TXT\n  ACMEServer -.- Challenge\n  ACMEServer -. 4b .-&gt; TXT</code></pre> <ol> <li>cert-manager creates a corresponding <code>Certificate</code> resources</li> <li>Based on the <code>Certificate</code> resource, cert-manager creates a <code>CertificateRequest</code> resource to request a signed certificate from the configured <code>ClusterIssuer</code></li> <li>The <code>CertificateRequest</code> will create an order with an ACME server (we use Let's Encrypt), which is represented by the <code>Order</code> resource</li> <li>Then cert-manager will perform a DNS-01 <code>Challenge</code>:<ol> <li>Create a DNS TXT record (contains a computed key)</li> <li>The ACME server retrieve this key via a DNS lookup and validate that we own the domain for the requested certificate</li> </ol> </li> <li>cert-manager stores the certificate (typically <code>tls.crt</code> and <code>tls.key</code>) in the <code>Secret</code> specified in the <code>Ingress</code> configuration</li> <li>Now you can access the HTTPS website with a valid certificate</li> </ol> <p>A much more detailed diagram can be found in the official documentation under certificate lifecycle.</p>"},{"location":"concepts/secrets-management/","title":"Secrets management","text":""},{"location":"concepts/secrets-management/#overview","title":"Overview","text":"<ul> <li>Global secrets are stored in the <code>global-secrets</code> namespace.</li> <li>Integrate with GitOps using External Secrets Operator.</li> <li>Secrets that can be generated are automatically generated and stored in the <code>global-secrets</code> namespace.</li> </ul> <p>Info</p> <p>Despite the name External Secrets Operator, global secrets are created in the same cluster and synced to other namespaces using the Kubernetes provider.</p> <p>While not supported by default in this project, you can also use other external providers such as HashiCorp Vault, AWS Secret Manager, Google Cloud Secret Manager, Azure Key Vault, 1Password, etc.</p> <pre><code>flowchart TD\n  subgraph global-secrets-namespace[global-secrets namespace]\n    secret-generator[Secret Generator] -- generate if not exist --&gt; source-secrets[Source Secrets]\n  end\n\n  subgraph app-namespace[application namespace]\n    ExternalSecret -- create --&gt; Secret\n    App -- read --&gt; Secret\n  end\n\n  ClusterSecretStore -- read --&gt; source-secrets\n  ExternalSecret --- ClusterSecretStore</code></pre>"},{"location":"concepts/secrets-management/#randomly-generated-secrets","title":"Randomly generated secrets","text":"<p>This is useful when you want to generate random secrets like admin password and store in global secrets.</p> ./kubernetes/platform/global-secrets/files/secret-generator/config.yaml<pre><code># Gitea\n- name: gitea.admin\n  data:\n    - key: password\n      length: 32\n      special: true\n\n# Dex\n- name: dex.grafana\n  data:\n    - key: client_secret\n      length: 32\n      special: false\n- name: dex.gitea\n  data:\n    - key: client_secret\n      length: 32\n      special: false\n\n# Registry\n- name: registry.admin\n  data:\n    - key: password\n      length: 32\n      special: true\n\n# Woodpecker\n- name: woodpecker.agent\n  data:\n    - key: secret\n      length: 32\n      special: false\n</code></pre>"},{"location":"concepts/secrets-management/#extra-third-party-secrets","title":"Extra third-party secrets","text":"<p>For third-party secrets that you don't control, add them to <code>terraform/terraform.tfvars</code> under the <code>extra_secrets</code> key, then run <code>make external</code>.</p> <p>They will be available as a Secret named <code>external</code> in the <code>global-secrets</code> namespace. You can use it with <code>ExternalSecret</code> just like any other global secret.</p>"},{"location":"concepts/secrets-management/#how-secrets-are-pulled-from-global-secrets-to-other-namespaces","title":"How secrets are pulled from global secrets to other namespaces","text":"<p>When you apply an <code>ExternalSecret</code> object, for example:</p> <pre><code>apiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n  name: gitea-admin-secret\n  namespace: gitea\nspec:\n  data:\n  - remoteRef:\n      conversionStrategy: Default\n      key: gitea.admin\n      property: password\n    secretKey: password\n  refreshInterval: 1h\n  secretStoreRef:\n    kind: ClusterSecretStore\n    name: global-secrets\n  target:\n    creationPolicy: Owner\n    deletionPolicy: Retain\n    template:\n      data:\n        password: '{{ .password }}'\n        username: gitea_admin\n      engineVersion: v2\n</code></pre> <p>This will create a corresponding Kubernetes secret:</p> <p><code>kubectl describe secrets -n gitea gitea-admin-secret</code></p> <pre><code>Name:         gitea-admin-secret\nNamespace:    gitea\nLabels:       &lt;none&gt;\nAnnotations:  reconcile.external-secrets.io/data-hash: &lt;REDACTED&gt;\n\nType:  Opaque\n\nData\n====\npassword:  32 bytes\nusername:  11 bytes\n</code></pre> <p>Please see the official documentation for more information:</p> <ul> <li>External Secrets Operator</li> <li>API specification</li> </ul>"},{"location":"concepts/tools-container/","title":"Tools container","text":"<p>The tools container makes it easy to get all of the dependencies needed to interact with the homelab.</p>"},{"location":"concepts/tools-container/#how-to-open-it","title":"How to open it","text":"<p>You can use the default Docker wrapper, or use Nix if you have Nix installed:</p> DockerNix <pre><code>make tools\n</code></pre> <pre><code>nix develop\n</code></pre> <p>Tip</p> <p>If you have <code>direnv</code> installed, you can run <code>direnv allow</code> once and it will automatically enter the Nix shell.</p> <p>It will open a shell like this:</p> <pre><code>[fullstackjam@ryzentower:~/Documents/homelab]$ echo hello\nhello\n</code></pre>"},{"location":"concepts/tools-container/#how-it-works","title":"How it works","text":"<ul> <li>All dependencies are defined in <code>./flake.nix</code></li> <li>When you run <code>make tools</code>, it will run a thin Docker wrapper with the <code>nixos/nix</code> image (because not everyone has Nix installed) and mount some required volumes</li> <li><code>nix develop</code> will start an interactive shell based on the Nix expression in <code>./flake.nix</code> and install everything from there</li> </ul>"},{"location":"concepts/tools-container/#known-issues","title":"Known issues","text":"<ul> <li>If your Docker engine is not running in rootless mode, all files created by the tools container will be owned by <code>root</code></li> </ul>"},{"location":"getting-started/user-onboarding/","title":"User onboarding","text":"For userFor admin <p>Run the following script:</p> <pre><code>kanidm login --url \"https://auth.fullstackjam.com\" --name idm_admin\n./scripts/onboard-user fullstackjam \"Jam Ma\" \"fullstackjam@outlook.com\"\n</code></pre> <p>Let the user scan the QR code or follow the link to set up passkeys or password + TOTP.</p>"},{"location":"getting-started/user-onboarding/#create-user","title":"Create user","text":"<p>Ask an admin to create your account, provide the following information:</p> <ul> <li> Full name (Jam Ma)</li> <li> Select a username (<code>fullstackjam</code>)</li> <li> Email address (<code>fullstackjam@example.com</code>)</li> </ul>"},{"location":"getting-started/user-onboarding/#install-companion-apps","title":"Install companion apps","text":"<p>For all users:</p> <ul> <li> A password manager (I personally recommend Bitwarden)</li> </ul> <p>For technical users:</p> <ul> <li> Docker</li> <li> Nix and direnv (optional, but highly recommended)</li> <li> Lens (optional, you can use the included <code>kubectl</code> or <code>k9s</code> command in the tools container)</li> </ul>"},{"location":"how-to-guides/alternate-dns-setup/","title":"Alternate DNS setup","text":"<p>Info</p> <pre><code>Skip this step if you already use the included Cloudflare setup\n</code></pre> <p>Before you can access the home page at https://home.example.com, you'll need to update your DNS config.</p> <p>Some options for DNS config (choose one):</p> <ul> <li>Change the DNS config at your domain registrar (already included and automated)</li> <li>Change the DNS config in your router (also works if you don't own a domain)</li> <li>Use nip.io (suitable for a test environment)</li> </ul>"},{"location":"how-to-guides/alternate-dns-setup/#at-your-domain-registrar-recommended","title":"At your domain registrar (recommended)","text":"<p>The default configuration is for Cloudflare DNS, but you can change the code to use other providers.</p>"},{"location":"how-to-guides/alternate-dns-setup/#in-your-router","title":"In your router","text":"<p>Tip</p> <p>If you don't have a domain, you can use the <code>home.arpa</code> domain (according to RFC-8375).</p> <p>You can add each subdomain one by one, or use a wildcard <code>*.example.com</code> and point it to the IP address of the load balancer. To acquire a list of subdomains and their addresses, use this command:</p> <pre><code>./scripts/get-dns-config\n</code></pre>"},{"location":"how-to-guides/alternate-dns-setup/#use-nipio","title":"Use nip.io","text":"<p>Preconfigured in the <code>dev</code> branch.</p>"},{"location":"how-to-guides/expose-services-to-the-internet/","title":"Expose services to the internet","text":"<p>Info</p> <p>This tutorial is for Cloudflare Tunnel users, please skip if you use port forwarding.</p> <p>Apply the <code>./external</code> layer to create a tunnel if you haven't already, then add the following annotations to your <code>Ingress</code> object (replace <code>example.com</code> with your domain):</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  annotations:\n    external-dns.alpha.kubernetes.io/target: \"homelab-tunnel.example.com\"\n    external-dns.alpha.kubernetes.io/cloudflare-proxied: \"true\"\n# ...\n</code></pre>"},{"location":"how-to-guides/updating-documentation/","title":"Updating documentation (this website)","text":"<p>This project uses the Di\u00e1taxis technical documentation framework. The website is generated using Material for MkDocs and can be viewed at k8s-gitops.fullstackjam.com.</p> <p>There are 4 main parts:</p> <ul> <li>Getting started (tutorials): learning-oriented</li> <li>Concepts (explanation): understanding-oriented</li> <li>How-to guides: goal-oriented</li> <li>Reference: information-oriented</li> </ul>"},{"location":"how-to-guides/updating-documentation/#local-development","title":"Local development","text":"<p>To edit and view locally, run:</p> <pre><code>make docs\n</code></pre> <p>Then visit localhost:8000</p>"},{"location":"how-to-guides/use-both-github-and-gitea/","title":"Use both GitHub and Gitea","text":"<p>Even though we self-host Gitea, you may still want to use GitHub as a backup and for discovery.</p> <p>Add both push URLs (replace my repositories with yours):</p> <pre><code>git remote set-url --add --push origin git@git.fullstackjam.com:fullstackjam/k8s-gitops\ngit remote set-url --add --push origin git@github.com:fullstackjam/k8s-gitops\n</code></pre> <p>Now you can just run <code>git push</code> like usual and it will push to both GitHub and Gitea.</p>"},{"location":"installation/post-installation/","title":"Post-installation","text":""},{"location":"installation/post-installation/#backup-secrets","title":"Backup secrets","text":"<p>Save the following files to a safe location like a password manager (if you're using the sandbox, you can skip this step):</p> <ul> <li><code>~/.ssh/id_rsa</code></li> <li><code>~/.ssh/id_rsa.pub</code></li> <li><code>./kubeconfig.yaml</code></li> <li><code>~/.terraform.d/credentials.tfrc.json</code></li> <li><code>./terraform/terraform.tfvars</code></li> </ul>"},{"location":"installation/post-installation/#admin-credentials","title":"Admin credentials","text":"<ul> <li>ArgoCD:<ul> <li>Username: <code>admin</code></li> <li>Password: run <code>./scripts/argocd-admin-password</code></li> </ul> </li> <li>Gitea:<ul> <li>Username: <code>gitea_admin</code></li> <li>Password: get from <code>global-secrets</code> namespace</li> </ul> </li> <li>Kanidm:<ul> <li>Usernames: <code>idm_admin</code></li> <li>Password: run <code>./scripts/kanidm-reset-password idm_admin</code></li> </ul> </li> <li>Other apps:<ul> <li>Username: <code>admin</code></li> <li>Password: get from <code>global-secrets</code> namespace</li> </ul> </li> </ul>"},{"location":"installation/post-installation/#run-the-full-test-suite","title":"Run the full test suite","text":"<p>After the homelab has been stabilized, you can run the full test suite to ensure that everything is working properly:</p> <pre><code>make test\n</code></pre> <p>Info</p> <p>The \"full\" test suit is still in its early stages, so any contribution is greatly appreciated.</p>"},{"location":"installation/sandbox/","title":"Development sandbox","text":"<p>The sandbox is intended for trying out the homelab without any hardware or testing changes before applying them to the production environment.</p>"},{"location":"installation/sandbox/#prerequisites","title":"Prerequisites","text":"<p>Host machine:</p> <ul> <li>Recommended hardware specifications:<ul> <li>CPU: 4 cores</li> <li>RAM: 16 GiB</li> </ul> </li> <li>OS: Linux (Windows and macOS are untested, please let me know if it works)</li> <li>Available ports: <code>80</code> and <code>443</code></li> </ul> <p>Install the following packages:</p> <ul> <li><code>docker</code></li> <li><code>make</code></li> </ul> <p>Clone the repository and checkout the development branch:</p> <pre><code>git clone https://github.com/fullstackjam/k8s-gitops\ngit checkout dev\n</code></pre>"},{"location":"installation/sandbox/#build","title":"Build","text":"<p>Open the tools container, which includes all the tools needed:</p> DockerNix <pre><code>make tools\n</code></pre> <pre><code>nix develop\n</code></pre> <p>Build a development cluster and bootstrap it:</p> <pre><code>make\n</code></pre> <p>Note</p> <p>It will take about 15 to 30 minutes to build depending on your internet connection</p>"},{"location":"installation/sandbox/#explore","title":"Explore","text":"<p>The homepage should be available at https://home.127-0-0-1.nip.io (ignore the security warning because we don't have valid certificates).</p> <p>See admin credentials for default passwords.</p> <p>If you want to make some changes, simply commit to the local <code>dev</code> branch and push it to Gitea in the sandbox:</p> <pre><code>git remote add sandbox https://git.127-0-0-1.nip.io/fullstackjam/k8s-gitops\ngit config http.https://git.127-0-0-1.nip.io.sslVerify false\n\ngit add foobar.txt\ngit commit -m \"feat: harness the power of the sun\"\ngit push sandbox # you can use the gitea_admin account\n</code></pre>"},{"location":"installation/sandbox/#clean-up","title":"Clean up","text":"<p>Delete the cluster:</p> <pre><code>k3d cluster delete homelab-dev\n</code></pre>"},{"location":"installation/sandbox/#caveats-compare-to-production-environment","title":"Caveats compare to production environment","text":"<p>The development cluster doesn't have the following features:</p> <ul> <li>There is no valid domain name, hence no SSL certificates (some services require valid SSL certificates)</li> <li>Only accessible on the host machine</li> <li>No backup</li> </ul> <p>Please keep in mind that the development cluster may be unstable and things may break (it's for development after all).</p>"},{"location":"installation/production/configuration/","title":"Configuration","text":"<p>Open the tools container, which includes all the tools needed:</p> DockerNix <pre><code>make tools\n</code></pre> <pre><code>nix develop\n</code></pre> <p>Note</p> <p>It will take a while to build the tools container on the first time</p> <p>Run the following script to configure the homelab:</p> <pre><code>make configure\n</code></pre> <p>Example</p> <pre><code>Text editor (nvim):\nEnter seed repo (github.com/fullstackjam/k8s-gitops): github.com/example/k8s-gitops\nEnter your domain (fullstackjam.com): example.com\n</code></pre> <p>It will prompt you to edit the inventory:</p> <ul> <li>IP address: the desired one, not the current one, since your servers have no operating system installed yet</li> <li>Disk: based on <code>/dev/$DISK</code>, in my case it's <code>sda</code>, but yours can be <code>sdb</code>, <code>nvme0n1</code>...</li> <li>Network interface: usually it's <code>eth0</code>, mine is <code>eno1</code></li> <li>MAC address: the lowercase, colon separated MAC address of the above network interface</li> </ul> <p>At the end it will show what has changed. After examining the diff, commit and push the changes.</p>"},{"location":"installation/production/deployment/","title":"Deployment","text":"<p>Open the tools container if you haven't already:</p> DockerNix <pre><code>make tools\n</code></pre> <pre><code>nix develop\n</code></pre> <p>Build the lab:</p> <pre><code>make\n</code></pre> <p>Yes it's that simple!</p>"},{"location":"installation/production/external-resources/","title":"External resources","text":"<p>Info</p> <p>These resources are optional, the homelab still works without them but will lack some features like trusted certificates and offsite backup</p> <p>Although I try to keep the amount of external resources to the minimum, there's still need for a few of them. Below is a list of external resources and why we need them (also see some alternatives below).</p> Provider Resource Purpose Terraform Cloud Workspace Terraform state backend Cloudflare DNS DNS and DNS-01 challenge for certificates Cloudflare Tunnel Public services to the internet without port forwarding ntfy Topic External notification service to receive alerts"},{"location":"installation/production/external-resources/#create-credentials","title":"Create credentials","text":"<p>You'll be asked to provide these credentials on first build.</p>"},{"location":"installation/production/external-resources/#create-terraform-workspace","title":"Create Terraform workspace","text":"<p>Terraform is stateful, which means it needs somewhere to store its state. Terraform Cloud is one option for a state backend with a generous free tier, perfect for a homelab.</p> <ol> <li>Sign up for a Terraform Cloud account</li> <li>Create a workspace named <code>homelab-external</code>, this is the workspace where your homelab state will be stored.</li> <li>Change the \"Execution Mode\" from \"Remote\" to \"Local\". This will ensure your local machine, which can access your lab, is the one executing the terraform plan rather than the cloud runners.</li> </ol> <p>If you decide to use a different Terraform backend, you'll need to edit the <code>terraform/versions.tf</code> file as required.</p>"},{"location":"installation/production/external-resources/#cloudflare","title":"Cloudflare","text":"<ul> <li>Buy a domain and transfer it to Cloudflare if you haven't already</li> <li>Get Cloudflare email and account ID</li> <li>Global API key: https://dash.cloudflare.com/profile/api-tokens</li> </ul>"},{"location":"installation/production/external-resources/#ntfy","title":"ntfy","text":"<ul> <li>Choose a topic name like https://ntfy.sh/random_topic_name_here_a8sd7fkjxlkcjasdw33813 (treat it like you password)</li> </ul>"},{"location":"installation/production/external-resources/#alternatives","title":"Alternatives","text":"<p>To avoid vendor lock-in, each external provider must have an equivalent alternative that is easy to replace:</p> <ul> <li>Terraform Cloud:<ul> <li>Any other Terraform backends</li> </ul> </li> <li>Cloudflare DNS:<ul> <li>Update cert-manager and external-dns to use a different provider</li> <li>Alternate DNS setup</li> </ul> </li> <li>Cloudflare Tunnel:<ul> <li>Use port forwarding if it's available</li> <li>Create a small VPS in the cloud and utilize Wireguard to route traffic via it</li> <li>Access everything via VPN</li> <li>See also awesome tunneling</li> </ul> </li> <li>ntfy:<ul> <li>Self-host your own ntfy server</li> <li>Any other integration supported by Grafana Alerting</li> </ul> </li> </ul>"},{"location":"installation/production/prerequisites/","title":"Prerequisites","text":""},{"location":"installation/production/prerequisites/#fork-this-repository","title":"Fork this repository","text":"<p>Because this project applies GitOps practices, it's the source of truth for my homelab, so you'll need to fork it to make it yours:</p> <p>Fork fullstackjam/k8s-gitops</p> <p>By using this project you agree to the license.</p> <p>License TL;DR</p> <ul> <li>This project is free to use for any purpose, but it comes with no warranty</li> <li>You must use the same GPLv3 license  in <code>LICENSE.md</code></li> <li>You must keep the copy right notice and/or include an acknowledgement</li> <li>Your project must remain open-source</li> </ul>"},{"location":"installation/production/prerequisites/#hardware-requirements","title":"Hardware requirements","text":""},{"location":"installation/production/prerequisites/#initial-controller","title":"Initial controller","text":"<p>Info</p> <p>The initial controller is the machine used to bootstrap the cluster, we only need it once, you can use your laptop or desktop</p> <ul> <li>A Linux machine that can run Docker (because the <code>host</code> networking driver used for PXE boot only supports Linux, you can use a Linux virtual machine with bridged networking if you're on macOS or Windows).</li> </ul>"},{"location":"installation/production/prerequisites/#servers","title":"Servers","text":"<p>Any modern <code>x86_64</code> computer(s) should work, you can use old PCs, laptops or servers.</p> <p>Info</p> <p>This is the requirements for each node</p> Component Minimum Recommended CPU 2 cores 4 cores RAM 8 GB 16 GB Hard drive 128 GB 512 GB (depending on your storage usage, the base installation will not use more than 128GB) Node count 1 3 or more for high availability <p>Additional capabilities:</p> <ul> <li>Ability to boot from the network (PXE boot)</li> <li>Wake-on-LAN capability, used to wake the machines up automatically without physically touching the power button</li> </ul>"},{"location":"installation/production/prerequisites/#network-setup","title":"Network setup","text":"<ul> <li>All servers must be connected to the same wired network with the initial controller</li> <li>You have the access to change DNS config (on your router or at your domain registrar)</li> </ul>"},{"location":"installation/production/prerequisites/#domain","title":"Domain","text":"<p>Buying a domain is highly recommended, but if you don't have one, see alternate DNS setup.</p>"},{"location":"installation/production/prerequisites/#bios-setup","title":"BIOS setup","text":"<p>Info</p> <p>You need to do it once per machine if the default config is not sufficent, usually for consumer hardware this can not be automated (it requires something like IPMI to automate).</p> <p>Common settings:</p> <ul> <li>Enable Wake-on-LAN (WoL) and network boot</li> <li>Use UEFI mode and disable CSM (legacy) mode</li> <li>Disable secure boot</li> </ul> <p>Boot order options (select one, each has their pros and cons):</p> <ol> <li>Only boot from the network if no operating system found: works on most hardware but you need to manually wipe your hard drive or delete the existing boot record for the current OS</li> <li>Prefer booting from the network if turned on via WoL: more convenience but your BIOS must support it, and you must test it throughly to ensure you don't accidentally wipe your servers</li> </ol> <p>Example</p> <p>Below is my BIOS setup for reference. Your motherboard may have a different name for the options, so you'll need to adapt it to your hardware.</p> <pre><code>Devices:\n  NetworkSetup:\n    PXEIPv4: true\n    PXEIPv6: false\nAdvanced:\n  CPUSetup:\n    VT-d: true\nPower:\n  AutomaticPowerOn:\n    WoL: Automatic  # Use network boot if Wake-on-LAN\nSecurity:\n  SecureBoot: false\nStartup:\n  CSM: false\n</code></pre>"},{"location":"installation/production/prerequisites/#gather-information","title":"Gather information","text":"<ul> <li> MAC address for each machine</li> <li> OS disk name (for example <code>/dev/sda</code>)</li> <li> Network interface name (for example <code>eth0</code>)</li> <li> Choose a static IP address for each machine (just the desired address, we don't set anything up yet)</li> </ul>"},{"location":"reference/changelog/","title":"Changelog","text":""},{"location":"reference/changelog/#001-alpha","title":"0.0.1-alpha","text":"<ul> <li>Bare metal provisioning with PXE</li> <li>LXD cluster</li> <li>Terraform state backend (etcd)</li> <li>RKE cluster</li> <li>Core services (Vault, Gitea, ArgoCD,...)</li> <li>Public services to the internet (via port forwarding or Cloudflare Tunnel)</li> </ul>"},{"location":"reference/contributing/","title":"Contributing","text":""},{"location":"reference/contributing/#how-to-contribute","title":"How to contribute","text":""},{"location":"reference/contributing/#bug-report","title":"Bug report","text":"<p>You can create a new GitHub issue with the bug report template.</p>"},{"location":"reference/contributing/#submitting-patches","title":"Submitting patches","text":"<p>Because you may have a lot of changes in your fork, you can't create a pull request directly from your <code>master</code> branch. Instead, create a branch from the upstream repository and commit your changes there:</p> <pre><code>git remote add upstream https://github.com/fullstackjam/k8s-gitops\ngit fetch upstream\ngit checkout upstream/master\ngit checkout -b contrib-fix-something\n\n# Make your changes here\n#\n# nvim README.md\n# git cherry-pick a1b2c3\n#\n# commit, push, etc. as usual\n</code></pre> <p>Then you can send the patch using GitHub pull request or <code>git send-email</code> to mail@fullstackjam.com.</p>"},{"location":"reference/faq/","title":"FAQ","text":""},{"location":"reference/faq/#is-it-necessary-to-install-linux-on-my-servers-before-setting-up-the-homelab","title":"Is it necessary to install Linux on my servers before setting up the homelab?","text":"<p>No, and that's the beauty of this setup. You start with empty hard drives, type a single command on your laptop/PC, and it will install the operating system for you automatically and in parallel over the network.</p>"},{"location":"reference/faq/#is-it-necessary-to-keep-the-pxe-server-running","title":"Is it necessary to keep the PXE server running?","text":"<p>No, the ephemeral PXE server is stateless, once Linux is installed on your servers, you can shut it down (or not, ideally, you don't even need to be aware of its existence). The Ansible setup in <code>./metal</code> is idempotent and will start the PXE server if needed.</p>"},{"location":"reference/license/","title":"License","text":"<p>Copyright \u00a9 2023 - 2025 Jam Ma</p> <p>MIT License</p> <p>Copyright (c) 2025 fullstackjam</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"reference/roadmap/","title":"Roadmap","text":"<p>Info</p> <p>Current status: ALPHA</p>"},{"location":"reference/roadmap/#alpha-requirements","title":"Alpha requirements","text":"<p>Literally anything that works.</p>"},{"location":"reference/roadmap/#beta-requirements","title":"Beta requirements","text":"<p>Good enough for tinkering and personal usage, and reasonably secure.</p> <ul> <li> Automated bare metal provisioning<ul> <li> Controller set up (Docker)</li> <li> OS installation (PXE boot)</li> </ul> </li> <li> Automated cluster creation (k3s)</li> <li> Automated application deployment (ArgoCD)</li> <li> Automated DNS management</li> <li> Initialize GitOps repository on Gitea automatically</li> <li> Observability<ul> <li> Monitoring</li> <li> Logging</li> <li> Alerting</li> </ul> </li> <li> SSO</li> <li> Reasonably secure<ul> <li> Automated certificate management</li> <li> Declarative secret management</li> <li> Replace all default passwords with randomly generated ones</li> <li> Expose services to the internet securely with Cloudflare Tunnel</li> </ul> </li> <li> Only use open-source technologies (except external managed services in <code>./external</code>)</li> <li> Everything is defined as code</li> <li> Backup solution (3 copies, 2 seperate devices, 1 offsite)</li> <li> Define SLOs:<ul> <li> 70% availability (might break in the weekend due to new experimentation)</li> </ul> </li> <li> Core applications<ul> <li> Gitea</li> <li> Woodpecker</li> <li> Private container registry</li> </ul> </li> </ul>"},{"location":"reference/roadmap/#stable-requirements","title":"Stable requirements","text":"<p>Can be used in \"production\" (for family or even small scale businesses).</p> <ul> <li> Complete documentation<ul> <li> Diagram as code</li> <li> Book (this book)</li> <li> Walkthrough tutorial and feature demo (video)</li> </ul> </li> <li> Configuration script for new users</li> <li> More dashboards and alert rules</li> <li> SLOs:<ul> <li> 99,9% availability (less than 9 hours of downtime per year)</li> <li> 99,99% data durability</li> </ul> </li> <li> Clear upgrade path</li> </ul>"},{"location":"reference/architecture/decision-records/","title":"Decision records","text":"<p>These are the records of design decisions for future reference in order to understand why things are the way they are. They are not permanent, we can change them in the future if better alternatives become available.</p> Template"},{"location":"reference/architecture/decision-records/#description-of-the-the-change","title":"Description of the the change","text":"<p>Context</p> <p>CHANGEME</p> <p>Decision</p> <p>CHANGEME</p> <p>Consequences</p> <ul> <li>CHANGEME</li> </ul>"},{"location":"reference/architecture/decision-records/#choosing-the-base-os","title":"Choosing the base OS","text":"<p>Context</p> <p>I've tried several distributions, and each has advantages and disadvantages. Ubuntu has a good (enough) balance between stability and new features.</p> <p>Decision</p> <p>Use Ubuntu24.04 as the base OS.</p> <p>Consequences</p> <p><code>\u00af\\_(\u30c4)_/\u00af</code></p>"},{"location":"reference/architecture/networking/","title":"Networking","text":"<pre><code>flowchart TD\n  subgraph LAN\n    laptop/desktop/phone &lt;--&gt; LoadBalancer\n    subgraph k8s[Kubernetes cluster]\n      Pod --&gt; Service\n      Service --&gt; Ingress\n\n      LoadBalancer\n\n      cloudflared\n      cloudflared &lt;--&gt; Ingress\n    end\n    LoadBalancer &lt;--&gt; Ingress\n  end\n\n  cloudflared -- outbound --&gt; Cloudflare\n  Internet -- inbound --&gt; Cloudflare</code></pre> <p>TODO (PR welcomed)</p>"},{"location":"reference/architecture/overview/","title":"Overview","text":""},{"location":"reference/architecture/overview/#components","title":"Components","text":"<pre><code>+--------------+\n|    ./apps    |\n|--------------|\n|  ./kubernetes/platform  |\n|--------------|       +------------+\n|   ./system   |- - - -| ./external |\n|--------------|       +------------+\n|   ./metal    |\n|--------------|\n|   HARDWARE   |\n+--------------+\n</code></pre> <p>Main components:</p> <ul> <li><code>./metal</code>: bare metal management, install Linux and Kubernetes</li> <li><code>./system</code>: critical system components for the cluster (load balancer, storage, ingress, operation tools...)</li> <li><code>./kubernetes/platform</code>: essential components for service hosting platform (git, build runners, dashboards...)</li> <li><code>./apps</code>: user facing applications</li> <li><code>./external</code> (optional): externally managed services</li> </ul> <p>Support components:</p> <ul> <li><code>./tools</code>: tools container, includes all the tools you'll need</li> <li><code>./docs</code>: all documentation go here, this will generate a searchable web UI</li> <li><code>./scripts</code>: scripts to automate common tasks</li> </ul>"},{"location":"reference/architecture/overview/#provisioning-flow","title":"Provisioning flow","text":"<p>Everything is automated, after you edit the configuration files, you just need to run a single <code>make</code> command and it will:</p> <ul> <li>(1) Build the <code>./metal</code> layer:<ul> <li>Create an ephemeral, stateless PXE server</li> <li>Install Linux on all servers in parallel</li> <li>Build a Kubernetes cluster (based on k3s)</li> </ul> </li> <li>(2) Bootstrap the <code>./system</code> layer:<ul> <li>Install ArgoCD and the root app to manage itself and other layers, from now on ArgoCD will do the rest</li> <li>Install the remaining components (storage, monitoring, etc)</li> </ul> </li> <li>(3) Build the <code>./kubernetes/platform</code> layer (Gitea, Grafana, SSO, etc)</li> <li>(4) Deploy applications in the <code>./apps</code> layer</li> </ul> <pre><code>flowchart TD\n  subgraph metal[./metal]\n    pxe[PXE Server] -.-&gt; linux[Fedora Server] --&gt; k3s\n  end\n\n  subgraph system[./system]\n    argocd[ArgoCD and root app]\n    nginx[NGINX]\n    rook-ceph[Rook Ceph]\n    cert-manager\n    external-dns[External DNS]\n    cloudflared\n  end\n\n  subgraph external[./external]\n    letsencrypt[Let's Encrypt]\n    cloudflare[Cloudflare]\n  end\n\n  letsencrypt -.-&gt; cert-manager\n  cloudflare -.-&gt; cert-manager\n  cloudflare -.-&gt; external-dns\n  cloudflare -.-&gt; cloudflared\n\n  subgraph platform[./kubernetes/platform]\n    Gitea\n    Woodpecker\n    Grafana\n  end\n\n  subgraph apps[./apps]\n    homepage[Homepage]\n    jellyfin[Jellyfin]\n    matrix[Matrix]\n    paperless[Paperless]\n  end\n\n  make[Run make] -- 1 --&gt; metal -- 2 --&gt; system -. 3 .-&gt; platform -. 4 .-&gt; apps</code></pre>"}]}